# 4. Advanced Features

## 4.1 Handshaking and auto detection for multiple boards

  Stacksynth modules are designed to be joined together to make a larger keyboard. Messages are exchanged between modules using a CAN bus.
  Typically, one module will have a receiver role and synthesise the notes that are played any module. The other modules transmit notes.
  Each module needs to be set up to generate notes from a different octave.
  
  The role and octave can be defined by compiling different versions of the code for each module.
  You can also allow them to be set with the user interface.
  However, a neater solution is to implement a handshaking system so that modules will automatically set up their roles and octaves on startup, depending on their position in the row of modules.
  
 ### Handshake signals
  The inter-module connectors include a pair of east/west handshake signals in addition to the CAN bus as demonstrated on Figure 1 below.
  
  <p align="center">
  <img src="https://user-images.githubusercontent.com/4660308/158452707-842ba356-4171-48b7-812b-7b6633ee56c8.png" width="600">
    <p align="center">
    <em>
  Figure 1: Inter-module connectors of east/west handshake signals
    </em>
</p>

  Each module can generate a handshake signal on its west and east connectors.
  It can also detect a signal generated by a neighbouring module.
  
 #### Sending a handshake signal
  There are not enough microcontroller pins to control the handshake outputs directly, so they are latched in a D flip-flop (DFF).
  An example of the west output is demonstrated on Figure 2 below.
  
  
  <p align="center">
  <img src="https://user-images.githubusercontent.com/4660308/158454133-825924ac-eeb8-4383-a99d-19f73bdbf71b.png" width="600">
    <p align="center">
    <em>
  Figure 2: Example of west output
    </em>
  </p>

  The state of the DFF is set with `OUT_PIN`, which is an output from the microcontroller that controls several functions.
  The value is latched on the rising edge of `R5` (`R6` for the east output), which is one of the row driver signals for the key scanning matrix.
  Therefore, whenever the key scanning matrix addresses row 5, the west handshake output is updated.
  You must set `OUT_PIN` to the correct value every time row 5 is accessed. Normally, you would do that in the key scanning routine, for example:
  ```
  for (i=0; i<7; i++) {
    selectRow(i);                     //Set row address
    digitalWrite(OUT_PIN,outBits[i]); //Set value to latch in DFF
    digitalWrite(REN_PIN,1);          //Enable selected row
    delayMicroseconds(3);             //Wait for column inputs to stabilise
    keyArray[i] = readCols();         //Read column inputs
    digitalWrite(REN_PIN,0);          //Disable selected row
  }
  ```
  Here, `outBits` is an array of bools that contains the values to latch in the DFF for each row. The DFFs have the following functions:
  | Row    | DFF function  |
  | ------ | ------------- |
  | 0      | Unimplemented |
  | 1      | Unimplemented |
  | 2      | Unimplemented |
  | 3      | OLED PSU Enable |
  | 4      | OLED nReset     |
  | 5      | Handshake output west |
  | 6      | Handshake output east |
  
  The OLED controls should be left high after startup.
  
#### Receiving a handshake signal
  The handshake inputs are connected to a FET that's placed in one node of the key scan matrix. An example of this is shown on Figure 3 below.
    <p align="center">
  <img src="https://user-images.githubusercontent.com/4660308/158459334-648ce6f8-ae1b-4bae-bc7d-41e3a351e395.png" width="300">
    <p align="center">
    <em>
  Figure 3: Example of handshake inputs connection through FET
    </em>
</p>
  A high input causes the FET to turn on, which, when the row is selected (driven low), pulls the column input low and is read as 0.
  The resistor ensures that the FET is off if nothing is connected to the input - this is read as 1.
  
  You read the handshake inputs just like a physical switch and the code example above already includes both handshake inputs in `keyArray`.
  The positions of the inputs in the matrix are:
  | HS Input | Row  | Column |
  | -------- | ----- | -------|
  | West     | 5    | 3      |
  | East     | 6    | 3      |
    

## 4.2 Automatic octave adjustments across multiple boards

In the music synthesizer, we implemented automatic octave detection across multiple boards by detecting the position of the connected boards using the inputs in the method explained above.

When a board was connected to another board, it would detect the presence of the adjacent board by checking the voltage levels on the east and west detect pins. This information was then used to determine the position of the board in the chain and adjust the octave accordingly (make octave lower when it's a left slave and higher otherwise).

## 4.3 Advanced Waveforms

In the music synthesizer, we used a look-up table (LUT) to create sine waves. A LUT is a pre-calculated table of values that can be accessed at runtime to avoid the need for complex mathematical calculations.

To create a sine wave LUT, we first calculated the values of sine function at regular intervals (e.g. every degree or every radian) and stored them in an array. We could then use this LUT to generate a sine wave by reading the appropriate value from the array at each sample point in time.

To create sawtooth and square waves using a LUT, we can use a similar technique. For sawtooth waves, we can create a ramp function LUT that increases linearly from 0 to 1 and then resets to 0, and then use this to generate a sawtooth wave by reading the appropriate value from the array at each sample point in time. For square waves, we can create a step function LUT that toggles between 0 and 1, and then use this to generate a square wave by reading the appropriate value from the array at each sample point in time.

In addition, we only store half of the sine wave LUT since it is an odd function, meaning that the values in the second half of the LUT are simply the negative values of the first half. This allows us to minimize the memory usage of the LUT without sacrificing the accuracy of the waveform.

## 4.4 PolyphonyÂ 

To implement polyphony in the music synthesizer, we added different waveforms together to create a richer and more complex sound. This was achieved using a technique called additive synthesis, where multiple waveforms were combined to create a single, more complex waveform. The implementation of polyphony allowed for the playing of multiple notes or voices simultaneously, with each voice assigned a different waveform, envelope, and other parameters, resulting in complex and expressive musical textures.

